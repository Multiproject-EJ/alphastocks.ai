import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..', '..');
const demoDir = path.resolve(repoRoot, 'workspace', 'src', 'data', 'demo');
const defaultOutputDir = path.resolve(repoRoot, 'supabase');

const args = process.argv.slice(2);
const outIndex = args.indexOf('--out');
const stdoutFlag = args.includes('--stdout');
const outputPath = outIndex !== -1 && args[outIndex + 1]
  ? path.resolve(repoRoot, args[outIndex + 1])
  : path.join(defaultOutputDir, 'seed.sql');

function escapeIdentifier(identifier) {
  return `"${identifier.replace(/"/g, '""')}"`;
}

function escapeString(value) {
  return value.replace(/'/g, "''");
}

function serializeValue(value) {
  if (value === null || value === undefined) {
    return 'NULL';
  }

  if (typeof value === 'number') {
    if (Number.isFinite(value)) {
      return String(value);
    }
    return 'NULL';
  }

  if (typeof value === 'boolean') {
    return value ? 'TRUE' : 'FALSE';
  }

  if (value instanceof Date) {
    return `'${value.toISOString()}'`;
  }

  if (typeof value === 'object') {
    const json = JSON.stringify(value);
    return `'${escapeString(json)}'::jsonb`;
  }

  return `'${escapeString(String(value))}'`;
}

function buildInsertStatement(table, row) {
  const columns = Object.keys(row);
  if (!columns.length) {
    return null;
  }

  const orderedColumns = columns.sort();
  const colList = orderedColumns.map(escapeIdentifier).join(', ');
  const values = orderedColumns.map((column) => serializeValue(row[column]));
  return `INSERT INTO ${escapeIdentifier(table)} (${colList}) VALUES (${values.join(', ')});`;
}

async function loadDatasets() {
  const entries = await fs.readdir(demoDir);
  const jsonFiles = entries
    .filter((file) => file.endsWith('.json'))
    .map((file) => path.resolve(demoDir, file))
    .sort();

  const datasets = [];

  for (const filePath of jsonFiles) {
    const raw = await fs.readFile(filePath, 'utf-8');
    const parsed = JSON.parse(raw);
    if (!parsed || !parsed.table || !Array.isArray(parsed.rows)) {
      console.warn(`Skipping ${path.basename(filePath)}: missing table metadata or rows array.`);
      continue;
    }

    datasets.push({
      filePath,
      table: parsed.table,
      rows: parsed.rows,
      metadata: parsed.metadata ?? {},
    });
  }

  return datasets;
}

async function ensureOutputDir(targetPath) {
  const dir = path.dirname(targetPath);
  await fs.mkdir(dir, { recursive: true });
}

async function main() {
  const datasets = await loadDatasets();

  if (!datasets.length) {
    console.error('No demo datasets found.');
    process.exitCode = 1;
    return;
  }

  const timestamp = new Date().toISOString();
  const tableNames = [...new Set(datasets.map((dataset) => dataset.table))];
  const truncateStatements = tableNames
    .map((table) => `TRUNCATE TABLE ${escapeIdentifier(table)} RESTART IDENTITY CASCADE;`)
    .join('\n');

  const lines = [
    `-- Generated by workspace/scripts/generateSupabaseSeed.js on ${timestamp}`,
    '-- Converts demo JSON fixtures into SQL INSERT statements ready for Supabase seeding.',
    'BEGIN;',
    '',
    '-- Optional cleanup: clear tables before inserting fresh data.',
    truncateStatements,
    '',
  ];

  for (const dataset of datasets) {
    const { filePath, table, rows, metadata } = dataset;
    const comment = `-- Dataset ${table} (${rows.length} rows) source: ${path.relative(repoRoot, filePath)}`;
    lines.push(comment);
    if (metadata.description) {
      lines.push(`-- ${metadata.description}`);
    }

    for (const row of rows) {
      const statement = buildInsertStatement(table, row);
      if (statement) {
        lines.push(statement);
      }
    }

    lines.push('');
  }

  lines.push('COMMIT;');
  lines.push('');

  const output = lines.join('\n');

  if (stdoutFlag) {
    process.stdout.write(output);
  } else {
    await ensureOutputDir(outputPath);
    await fs.writeFile(outputPath, `${output}\n`, 'utf-8');
    console.log(`Seed script written to ${path.relative(repoRoot, outputPath)}`);
  }
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
